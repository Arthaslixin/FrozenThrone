1. 人生是你的
    - 尝试改变，你有权选择

2. 我的源码被猫吃了
    - 分析自己能控制的事情，可以负起的责任，犯错误时勇敢的承认并积极补救。
    - 提供选择，别找借口，自己不能控制的事情，要计划出应急方案。

3. 软件的熵
    - 不要搁置“破窗”不去修理，不然整个系统会迅速恶化。
    - 先勿损害，不要只是因为一些东西非常危急，就去造成附带伤害。

4. 石头做的汤和煮熟的青蛙
    - 做推动变革的催化剂，先提出小的合理的请求，然后不断完善，一旦有成果就展示出来，吸引人们完善它。

5. 够好即可的软件
    - 早给用户一个毛糙的软件比一年后给一个打磨光亮的版本好（用户的需求可能在一年后已不同，而且用户反馈能引领更好的方案）

6. 知识组合
    - 对知识组合做定期投资
    - 批判性的分析你读到和听到的东西

7. 交流
    - 了解听众，用听众会感兴趣的方式

8. 优秀设计的精髓
    - ETC(Easier To Change):优秀的设计更容易做变更

9. DRY-邪恶的重复
    - 维护并不始于程序发布，程序员一直处于维护模式下，从未间断，项目需求和我们的理解每天都在变化，维护是整个开发过程中的常态。
    - DRY原则：在一个系统中，每一处知识都必须单一、明确、权威地表达
    - DRY强调的是，在两个地方表达的东西其实是相同的，只是表达方式有可能完全不同。反之，表达不同知识的函数，即使他们的代码可能相同，但这并不是重复。

10. 正交性
    - 正交性象征着独立性或解耦性。
    - 不要依赖那些你无法控制的东西, 比如不要用电话号码做为客户标识符
    - 避免全局数据

11. 可逆性
    - 不设最终决定
    - 放弃追逐时尚，没有人知道未来会怎样。

12. 曳光弹
    - 由于用户以前从未见过这样的系统，所以需求可能是模糊的，我们面临大量的位置因素，在完成以前，工作所处的环境一定会改变。
    - 使用曳光弹找到目标（先用骨架尝试跑通，再逐渐丰满）
    - 曳光弹并不总能击中找到目标，需要不断调整。
    - 曳光代码对阵原型制作
        - 原型的目标是探索最终系统的特定方面，如果有了一个真正的原型则会扔掉验证构思是捆绑在一起的所有东西，并总结经验教训，最后正确地重新编码。（确定原型后，并不会在原型上持续开发，而是在最终的环境中开发，与现实世界交接）
        - 曳光代码方法解决的是不同的问题。你需要知道应用程序作为一个整体，是如何整合在一起的。曳光代码构建的程序是简单但能工作的，随着时间的推移，逐渐把新的功能添加到这个框架中，但是框架保持不变，系统会继续这样运作，一直和一开始完成曳光代码时一致。
    - 我们强调：原型生成的是一次性代码；曳光代码虽然简单但完整，他是最终系统框架的组成部分。可以将原型制作看作是在发射一颗曳光弹之前进行的侦查和情报收集工作。

13. 原型与便签
    - 每个原型都是为了测试一个特定方面。软件模型用来分析和暴露风险，以一种能答复降低成本的方式获得修正的机会。
    - 需要做原型的东西: 任何有风险的东西，任何之前没有尝试过或对最终系统来说很关键的东西，任何未经证实、实验性或可疑的东西，以及任何让你不舒服的东西。原型设计是为了学习经验。它的价值不在于产生的代码，而在于吸取的教训。
    - 当制作一个原型时，哪些细节可以忽略 ？
        - 正确性：你可以在适当的地方使用替代数据。
        - 完整性：原型只需要满足有限的功能。
        - 健壮性：错误检查可以不完整，甚至完全没有。
        - 格式：原型代码可能并不需要太多注释和文档。
    - 原型不必非要使用代码，在白板上贴一些便签和索引卡可能就够了。
    - 不要把原型用于产品

14. 领域语言(todo)
    - 计算机的语言会影响你怎样思考问题，影响你怎样看待信息的传播。

15. 估算
    - 估算答案的单位会反映想要传达的精确性。
    - 所有的估算都是基于对问题的建模。技巧是：问问已经做过的人。
    - 需要掌握问题域的范围。范围通常是问题的隐含前提。（如果xxxx，在xxxx的情况下，我估计的时间是xxxx）
    - 1.对系统建模 2.把模型分解成组件 3.确定组件中每个参数的值 4.计算答案 5.记录你的估算能力
    - 估算项目进度，有两种减少不确定性的技巧
        - 粉刷导弹：现实世界中的估算往往不会仅有一个数字，而是由一系列的预案构成。计划评审技术（Program Evaluation Review Techningue，PERT）每个PERT任务都有一个乐观的、一个最有可能的和一个悲观的估算。任务被排列进一个互相依赖的网络中，然后实用一些简单的统计方法来确定整个项目可能的最佳和最差时间。
        - 吃掉大象：我们发现，确定一个项目的时间表的唯一方法，通常来自于在这个项目上获得的经验。只要重复下列步骤做增量开发，不一定会陷入不做就无法预估的悖论。经历多次迭代，逐步估算时间，就好像吃掉大象的方法是一次咬一口
            - 检查需求
            - 分析风险
            - 设计、实现、集成
            - 和用户一起验证
    - 根据代码不断迭代进度表

16. 纯文本的威力
    - 什么是纯文本：纯文本是由可打印字符组成的，构成某种用来传递信息的形态。我们希望纯文本可以被人类直接阅读。
    - 将知识用纯文本保存
        - 为防备老化而加的保险：人类可读形式的数据与自描述数据，会比所有其他形式的数据，已经创建数据的应用程序，更有生命力。
        - 杠杆效应：计算领域中的所有工具都可以对纯文本进行操作。
        - 易于测试

17. Shell游戏
    - 图形工具的好处是：所见即所得；弱势之处是：所见即全部
    - 发挥Shell命令的威力

18. 加强编辑能力
    - 游刃有余的使用编辑器

19. 版本控制
    - 共享目录绝非版本控制
    - 永远使用版本控制，即使只有一个人开发，即使这项目一周就会结束，即使操作的不是源码。所有的内容都应该在版本控制之下。
    - 把版本控制视为项目中枢

20. 调试
    - 调试只是在解决问题并为此攻关。我们应该把精力集中在解决问题上，而不是归咎于他人。Bug是不是你的错并不重要，问题仍然要你来面对。
    - 调试心态：不要恐慌！
    - 从哪里开始：在查Bug之前，请确保正在处理的代码没有警告。
    - 调试策略：一旦你觉得自己知道发生了什么，就该去查明————以程序视角看————发生了什么。
    - 调试最重要的原则是：修代码前先让代码在测试中失败(用单一指令就能重现bug)
    - 读一下那该死的出错信息！而不是直接看代码
    - 版本间回退：二分法
    - 输出日志及跟踪信息：在每一步都打一些关键信息
    - 找个橡皮鸭
    - 排除法：操作系统和编译器或第三方产品中都可能存在Bug，但这不是首先要考虑的。如果你”只改变了一个东西“，然后系统就不工作了，那么这个东西就最可能直接或间接的负有责任。
    - 让人吃惊的元素：不要坚信某处代码无懈可击：你真的测试了所有的边界条件吗？使用了多年的代码真的不可能还有bug吗？
    - 当遇到一个意外的Bug时，除了修复它，还需要确定为什么没有更早的发现这个错误。

21. 文本处理
    - 学习一门文本处理语言！！

22. 工程日记
    - 日记本有三大好处
        - 它比记忆更可靠
        - 它为你提供了一个地方用来保存与当前任务无关的想法
        - 它就像一种橡皮鸭
    - 试着拥有一本工程日记，使用纸和笔而不是文件或维基。

23. 契约式设计
    - 这是一种简单但功能强大的技术，侧重于文档化（并约定）软件模块的权利和责任，以确保程序的正确性。什么是正确的程序？不多也不少，正好完成它主张要做的事情的程序。文档化及对主张进行检验是契约式设计（DBC）的核心。
    - 软件系统每一个函数和方法都力争有所作为：
        - 前置条件：例程的需求。一个例程永远不应该在前置条件被违反的时候被调用。传递良好的数据是调用者的责任。
        - 后置条件：例程完成时世界的状态。例程不允许无限循环。
        - 类的不变式：（？）从调用者的角度来看，类会确保该条件始终为真。在例程的内部处理期间，可以不遵守不变式，但是当例程退出并将控制权返回给调用者时，不变式必须为真。（？）
    - 如果调用者满足了例程的所有前置条件，则例程应保证在完成时所有后置条件和不变式都为真。如果任何一方未能履行契约，就会调用补救措施————可能是抛出异常，或者程序终止。
    - 在开始之前，对要接受的东西要求严格一点，并且尽可能少的对回报做出承诺。
    - 实现DBC：在编写代码之前，简单的列出输入域的范围、边界条件是什么、例程承诺要交付什么，没有承诺要交付什么。
    - 尽早崩溃！通过使用断言或DBC机制来验证前置条件、后置条件和不变式，可以尽早崩溃并报告有关问题更准确的信息。

24. 死掉的程序不会说谎。
    - 崩溃，不要制造垃圾。一旦代码发现本来不可能发生的事情已发生，程序就不再可靠，所以要尽快终止它。
    - 一个死掉的程序，通常比一个瘫痪的程序，造成的损害要小得多

25. 断言式编程
    - 使用断言去预防不可能的事情。无论何时，你发现自己在想”当然这是不可能发生的“时，添加代码来检查这一点。
    - 不要使用断言来代替真正的错误处理。断言检查的是不可能发生的事情。
    - 断言与副作用：我们为检测错误而添加的代码不要滋生新的错误（比如调试本身不要改变系统的行为）
    - 保持断言常开
        - 测试不可能发现所有的Bug。
        - 程序是在一个危险的世界中运行的。

26. 如何保持资源的平衡
    - 有始有终：分配资源的函数或对象，对释放资源应负有责任。
    - 在局部行动
        - 嵌套的分配：对于一次需要不止一个资源的例程，可以对这个资源分配的基本模式做一些扩展。
            - 释放资源的顺序与分配资源的顺序相反。在这样的次序下，如果一个资源包含对另一个资源的引用，就不会让被依赖的资源提前释放。
            - 在代码的不同位置，如果都会分配同一组资源，就始终以相同的顺序分配他们。（这将减少死锁的可能性）
            - 保持平衡与异常。如果抛出异常，如何保证之前分配给异常的所有内容都已依次释放？通常有两个选择：
            - 利用变量的作用域（C++或Rust中的栈变量）
            - 使用try...catch代码块中的finally字句
        - 当你无法保持资源的平衡时。有时，资源分配的基本模式并不合适。这种情况通常出现在使用动态数据结构的程序中。一个例程会分配一个内存区域并将它链接到某个更大的结构中，在哪里这块内存可能会停留一段时间。这里有一个技巧，可用来为内存分配建立一个语义不变式。你需要确定由谁来负责聚合数据结构中的数据，以及当释放顶层结构时会发生什么。有三种主要的方案：
            - 顶层结构同时负责释放它所包含的任何子结构。然后这些结构递归地删除他们包含的数据等。
            - 顶层结构只做简单的释放。它所指向的每个结构（没有其他地方引用）都变得无处引用。
            - 如果包含任何子结构，则顶层结构拒绝释放自己。
        - 检查平衡

27. 不要冲出前灯范围。
    - 小步前进————由始至终：总是采取经过深思熟虑的小步骤，同时检查反馈，并在推进前不断调整。把反馈的频率当做速度限制，永远不要进行“太大”的步骤或任务。反馈指的是任何能独立证实或否定你行为的东西。
    - 怎样的任务才算太大？任何大到需要“占卜”的任务。为将来的任务做设计要适可而止：別超过你能看见的范围。
    - 避免占卜：很多时候，明天看起来会和今天差不多，但不要指望一定会这样。

28. 解耦
    - 解耦代码让改变更容易
    - 只管命令不要询问(TDA)：不应该根据对象的内部状态做出决策，然后更新该对象。
    - 德墨忒尔法则（LoD）：定义在C类中的函数只应该调用：
        - C类其他实例的方法
        - 它的参数
        - 它所创建出来的对象的方法，包括在栈上和堆上的对象
        - 全局变量（现在我们不喜欢全局变量）
    - 不要链式调用方法(非常确定调用的东西不会改变时除外)
    - 邪恶的全局化：全局可访问的数据是应用程序组件之前耦合的潜在来源。
    - 避免全局数据（全局数据包括单例和外部资源）
    - 如果全局唯一非常重要，那么将它包装到API中
    - 继承增加了耦合

29. 在现实世界中抛球杂耍（如何编写响应式应用程序）
    - 事件：事件表达出信息的可用性。它可能来自外部世界（用户点击），也可能是内部的（计算结束）。
        - 有限状态机
        - 观察者模式
        - 发布/订阅
        - 响应式编程与流
    - 有限状态机：状态机基本上就是怎样处理事件的一份规范。它由一组状态组成，其中一个是当前状态。对于每个状态，我们列出对该状态有意义的事件。对于每个事件，我们定义出系统新的当前状态。FSM的妙处在于，我们可以将其纯粹的表示为数据。
        - 状态机是一个开始，但其并不能解决所有与事件相关的问题。状态太复杂会导致状态表难以维护。
    - 观察者模式：在观察者模式中，我们有一个事件源，被称为被观察对象；而客户列表，也即观察者，会对其中的事件感兴趣。
        - 创建一个观察对象不需要太多的代码：将一个函数引用压入一个列表，然后在事件发生时调用那些函数即可。
        - 观察者模式的问题：因为每个观察者都必须与观察对象注册在一起，所以它引入了耦合。此外，由于在典型的实现中，回调是由观察对象以同步的方式内联处理的，因此可能会导致性能瓶颈。
    - 发布/订阅：在pubsub模式中，我们有发布者和订阅者，它们是通过信道连接在一起的。它同时解决了耦合和性能问题。
        - pubsub是一种很好的解耦异步事件处理过程的技术。它允许在应用程序运行时添加和替换代码，而无须更改现有代码。
        - 其缺点是，很难查看在一个重度使用pubsub模式的系统中发生了什么：无法在查看发布者的同时立即看到有哪些订阅者涉及特定的消息。
    - 响应式编程、流与事件
        - 流让我们把事件当做数据集合来对待，因此可以用来在代码中触发响应。
    - 事件无处不在：事件到处都是。有些是显而易见的：一次按钮点击，一个计时器到期。有些则没那么简单：有人登录进来，文件中的一行匹配了一个模式。但是，无论事件源是什么，围绕事件编写的代码逗比对应的线性代码更容易响应，解耦效果也更好。

30. 变换式编程
    - 所有程序其实都是对数据的一种变换———将输入转化成输出。然而，当我们在构思设计时，很少考虑创建变换过程。我们需要重新把程序视为从输入到输出的一个变换。
    - 编程讲的是代码，而程序谈的是数据
        - 寻找变换：从需求开始并确定它的输入和输出。
        - 处理数据要用管道思想，创建一个我们需要的变换链。而面向对象的封装会引入很多耦合，让系统难于更改。
    - 不要囤积状态，传递下去
        - 永远不在变换之间传递原始值。取而代之的是，将值封装在一个数据结构（或类型）中，该结构可以告知我们所包含的值是否有效。
31. 继承税
    - 通过继承共享代码的问题
        - 继承就是耦合。不仅子类耦合到父类，以及父类的父类等，而且使用子类的代码也耦合到所有祖先类。
        - 通过继承构建类型的问题：为了表示类的细微差别会导致极其复杂的类型结构，多重继承问题也随之而来。
    - 不要付遗产税
        - 更好的替代方案：
            - 接口与协议
            - 委托
            - mixin与特征
    - 尽量用接口来表达多态
        - 委托?
    - 用委托提供服务：“有一个“胜过”是一个“
        - 为类和对象扩展新的功能，但不用继承。那么就创建一组函数，给这个函数组起一个名字，然后用它去扩展一个类或对象（我们称之为mixin）。所有这些实现都具有这样一个特性：将现有事物和新事物的功能合并在一起。
    - 利用mixin共享功能
32. 配置
    - 如果代码依赖某些值，而这些值在应用程序发布后还有可能改变，那么就把这些值放在应用程序外部。当应用程序于不同的环境中运行，而且面对不同的用户时，将和环境相关、用户相关的值放在应用之外。
    - 使用外部配置参数化应用程序。
        - 外部服务（数据库、第三方API等）的证书
        - 日志级别与日志位置
        - 应用程序使用的端口、IP地址、机器名及集群名
        - 特定环境的校验参数
        - 外部设置参数，例如税率
        - 特定场合的格式化细节
        - 许可证密钥
    - 静态配置
        - 将配置信息包装在一个（瘦）API后面，这将使代码从配置的呈现细节中解耦出来。
    - 配置服务化
        - 在身份认证和访问权限控制将多个应用程序的可见内容阻隔开的情况下，让多个应用程序可以共享配置信息
        - 配置的变更可以在任何地方进行
        - 配置数据可以通过专有UI维护
        - 配置数据变得动态
33. 打破时域耦合
    - 时间对我们来说有两个重要的方面：并发性（在同一时刻发绳的多件事情）以及次序（事情在时间轴上的相对位置）
    - 通过分析工作流来提高并发性
    - 并发和并行的区别：并发性是一种软件机制，而并行性则和硬件相关。
34. 共享状态是不正确的状态
    - 非原子更新
        - 信号量和其他形式的互斥: 简单而言，信号量是一个在同一时间只能让一个人持有的东西。你可以创建一个信号量，然后利用它来控制对其他资源的访问。但是这个方法只有在所有人都使用时才有效。
        - 资源具备事务性: 将锁放在资源的get方法中
        - 多个资源的事务: 将需要的多个资源合并看成是一种资源
        - 非事务性更新
    - 随机故障通常是并发问题
35. 角色与进程
    - 角色是一个独立的虚拟处理单元，具有自己的本地（且私有的）状态。每个角色都有一个信箱。当消息出现在信箱中且角色处于空闲状态时，角色被激活并开始处理消息。处理完该条消息后，它将继续处理信箱中的其他消息，如果信箱是空的，则返回休眠状态。
      在处理消息的过程中，一个角色可以创建其他角色，可以向其他认识的角色发送消息，也可以创建一个新的状态，用来处理下一条消息时做为当前状态。
    - 进程通常代表一种更通用的虚拟处理机，它一般由操作系统实现，可以让并发处理更容易。进程也能（根据约定）被约束为以角色的形式运转，我们在这里说的就是这类进程。

    - 角色只会是并发的
        - 没有一件事是可控的
        - 系统中唯一的状态保存在消息和每个角色的本地状态中
        - 所有的消息都是单向的
        - 角色会将每一条消息处理完，一次只会处理一条。
        因此，角色以并发方式来异步的执行，并且不共享任何内容。如果有足够的物理处理器，就可以在每个处理器上运行一个角色。如果只有一个处理器，那么某些运行时可以处理角色之间的上下文切换。无论以哪种方式，在角色内运行的代码都是相同的。
    - 用角色实现并发性时不必共享状态
    - ？但这没有解决因为派不足导致的并发问题？
36. 黑板
    - 数据到达的顺序无关紧要：当发布一个事实时，可以出发适当的规则。反馈也很容易处理：任何一组规则的输出都可以发布到黑板上，从而出发更多适用的规则。
    - 使用黑板来协调工作流
37. 听从蜥蜴脑
    - 倾听你内心的蜥蜴
        - 停止你正在做的事情。给自己一点时间和空间，让大脑自我组织。
        - 如果上一条不奏效，则试着把问题外化。把正在写的代码涂画到纸上，或者向你的同事解释一下是怎么回事，向橡皮鸭解释一下也行。
        - 如果仍不奏效，那我们需要告诉大脑：打算要做的事情，并没有那么重要。可以用做原型的方式来干这件事。
    - 做原型
        1. 在便签上写下“我正在做原型”，然后贴在屏幕的一侧。
        2. 提醒自己，原型注定要出问题。提醒自己，原型即使没有出问题也会被扔掉。
        3. 在空的编辑器窗口中，写一条注释，用几句话描述你想学点什么或做点什么。
        4. 开始编码
        - 如果你开始产生疑虑，就看看便签。
        - 如果在编码的过程中，那个挥之不去的疑虑突然变成了实实在在的担忧，那么把他弄清楚。
        - 如果在实验结束后仍旧不舒服，那就重新从散步、谈话和休息开始。
    - 不仅仅是你的代码
        - 慢慢啃别人的代码，在看似重要的地方做笔记。
        - 当发现事情以一种奇怪的方式完成时，把他记下来，然后试着寻找模式。
38. 巧合式编程
    - 编程应该深思熟虑
    - 怎样算是靠巧合编程
        - 不知道为什么代码会出错，是因为一开始就不知道它为什么能工作。
        - 实现造成的偶然事件：事情之所以这样，仅仅是因为代码当前的写法如此。你最终依赖的是，一些因文档中没有记在而未考虑到的边界条件，或者将错就错的结果。
            - 它可能并非真的在工作————或许只是看起来这样。
            - 你所依赖的边界条件可能只是一个偶然现象。在不同的环境中（屏幕分辨率、CPU核心数），它的行为可能不同。
            - 未计入文档的行为可能会随着库的下一个版本而改变.
            - 额外的不必要的调用会使代码变慢。
            - 额外的调用增加了引入新Bug的风险。
        - 对于调用的例程，其只应依赖文档上的行为。如果你做不到，不管出于什么原因，那就把你的假设记录下来。
    - 和结果相近是不够的
    - 虚幻的模式：不要假设，要证明。
    - 环境造成的偶然事件：找到恰好能用的答案和找到正确的答案不是一回事。
    - 不要依赖巧合编程
    - 如何深思熟虑的编程
        - 时刻注意你在做什么
        - 应该可以向一个更初级的程序员详细解释一下代码
        - 不要再黑暗中编码。如果不确定它为什么能用，就不会知道它为什么出错。
        - 要按计划推进
        - 只依赖可靠的东西
        - 将假设文档化
        - 不要只测试代码，还要测试假设
        - 为你的精力投放拍一个优先级。
        - 不要成为历史的奴隶。
39. 算法速度
    - 常识判断
        - 简单循环: O(n)————时间增加和n线性相关。例子有穷举查找、找到数组中最大值，以及生成校验和。
        - 嵌套循环: O(n^2) 通常出现在排序算法中，例如冒泡排序。
        - 二分法: O(lg n) 对有序数列二分查找、遍历二叉树、找到机器字的最高位
        - 组合问题: 当算法开始关注事务的排列时，运行时间可能会失控。通常，在特定问题领域需要使用启发式算法来减少这些算法的运行时间。
    - 评估算法的级别
    - 对估算做测试
        - 最好的不会永远最好。不要过早的优化。
40. 重构
    - 定义：重组现有代码实体、改变其内部结构而不改变其外部行为的规范式技术。
        1. 这项活动是有规范的，不应随意为之。
        2. 外部行为不变; 现在不是添加功能的时候
    - 重构并不是一种特殊的、隆重的、偶尔进行的活动。重构是一项日复一日的工作，需要采取低风险的小步骤进行。这是一种有针对性的、精确的方法，有助于保持代码抑郁更改，而不是对代码库进行自由的、大规模的重写。
    - 为了保证外部行为没有改变，你需要良好的自动化单元测试来验证代码的行为。
    - 何时该重构
        - 重复
        - 非正交设计
        - 过时的知识
        - 性能
        - 通过了测试：如果添加了少量代码，并且通过了一个额外的测试，现在就有了一个很好的机会，来深入研究并整理刚刚编写的代码。
    - 尽早重构，经常重构
    - 怎样重构
        - 不要试图让重构和添加功能同时进行。
        - 在开始重构之前，确保有良好的测试。尽可能多地运行测试。
        - 采取简短而慎重的步骤。
41. 为编码测试
    - 测试与找bug无关：我们相信，测试获得的主要好处发生在你考虑测试及编写测试的时候，而不是在运行测试的时候。
    - 测试驱动编码：为方法写一个测试的考虑过程，使我们得以从外部看待这个方法，这让我们看起来是代码的客户，而不是代码的作者。
    - 测试是代码的第一个用户
    - 测试驱动开发（TDD）
        1. 决定要添加一小部分功能
        2. 编写一个测试。等相应功能实现后，该测试会通过
        3. 运行所有测试。
        4. 尽量少写代码，只需保证测试通过即可。
        5. 重构代码：看看是否有办法改进刚刚编写的代码。确保完成时仍然通过。
        - 实践一下TDD，但是也不要忘记时不时停下来看看大局。不要做冗余的大量测试。
    - 既非自上而下，也不自下而上，基于端对端构建
        - 我们坚信，构建软件的唯一方法是增量式的。构建端到端功能的小块，一边工作一边了解问题。应用学到的知识持续充实代码，让客户参与每一个步骤并让他们指导这个过程。
    - 为测试做设计
        - 临时测试：用来临时测试打印的log，之后应该添加到现有的单元测试库中。
        - 开一扇测试窗口：一般而言，你可以留一个特性开关，为特定用户或用户组启用额外的诊断信息。
        - 测试文化：所有的测试最终都应能通过。
42. 基于特性测试
    - 让计算机来做一些测试，它不会受你的先入之见的影响。
    - 使用基于特性的测试来校验假设
        - 建立一些规则来生成输入，设定好断言来验证输出，就可以任其发展。
43. 出门在外注意安全
    - 剩下的90%: 在完成了90%的代码时，不要以为马上就完成了全部的工作。接下来要做的是分析代码中那些可能出错的路径，并将其添加到测试套件中。你要考虑传入错误的参数，泄露的资源或资源不存在等此类事情。通过隐藏问题来实现安全性是行不通的。
    - 安全性的基本原则
        1. 将攻击面的面积最小化
            - 代码复杂性吱声攻击载体
            - 输入数据是一种攻击载体
            - 未经身份验证的服务成为攻击载体
            - 经过身份验证的服务成为攻击载体：要淘汰不使用的、旧的或过时的用户和服务。
            - 输出数据成为攻击载体：不要泄露比如"该密码已被其他用户使用"这种信息
            - 调试信息成为攻击载体：要确保任何"测试窗口"和运行时异常报告都已受到保护，不会被间谍看见
        2. 最小特权原则
            - 不要自动获取类似root或Administrator这样的最高级别权限
        3. 安全的默认值
            - 默认值应该是最安全的。这些值可能不是对用户最右好或最方便的，但是最好让每个人自己为安全性和方便性之间的权衡做决定。
        4. 敏感数据要加密
            - 不要将个人身份信息、财务数据、密码或其他凭据，已纯文本的形式保存在数据库或其他外部文件中。
            - 不要把保密内容、API密钥、SSH密钥、加密密码或其他凭据，和源码一起提交到版本控制中。
        5. 维护安全更新
    - 常识与密码学
        - 当涉及加密时，第一条也是最重要的一条规则是：永远不要自己做。

44. 事物命名
    - 尊重文化（约定俗成、社区文化）
    - 一致性：
        - 每个项目都有自己的词汇表：对团队有特殊意义的术语。重要的是，团队中的每个人都知道这些词的意思，并始终如一地使用他们。
        - 一种方法是鼓励大量的交流。
        - 另一种方法是使用项目术语表
    - 好好取名；需要时更名
45. 需求之坑
    - 无人确切知道自己想要什么
    - 需求神话
        - 尽量要在开始之前就理解整个问题
        - 我们的工作是帮助人们了解他们想要什么
    - 如治疗般编程
        - 新手开发人员经常犯的错误是，把对需求的声明照单全收，然后实现对应方案。根据我们的经验，最初对需求的声明，往往并非绝对化的需求。客户可能没有意识到这一点，但一定希望你能一起去探索。
    - 需求是从反馈循环中学到的
        - 你的工作是帮助客户理解他们所陈述需求的后果。你通过激发反馈来做到这一点，并让他们利用反馈来完善自己的想法。
        - 务实的程序员嫁给你所有项目视为采集需求的练习。每次迭代都以客户的直接反馈结束。
        - 带入客户的立场：和用户一起工作以便从用户角度思考。
    - 需求与策略
        - 策略即元数据（Design for common）:针对更普遍的情况做实现，至于系统需要支持的那种特定类型的东西，只是通用实现在加入策略信息后的示例。
    - 需求与现实
        - 成功的工具会让用的人觉得称手。
    - 需求的文档化
        - 我们相信，最好的需求文档，或许也是唯一的需求文档，就是可以工作的代码。
        - 对客户需求的理解文档仍然重要，只是不必交付，只是帮助指导实现过程的路标。
        - 需求文档不是为客户准备的
            - 不要做一份及其详尽复杂的文档给客户看。
        - 需求文档是为计划准备的
    - 过度规范化
        - 生成需求文档的另一大危险是过于具体。好的需求是抽象的。最简单最能准确反应业务需求的语句是最好的。这并不意味着可以模棱两可————必须将底层语义的不变式做为需求来紧抓不放，并将特定的或当前的工作实践作为策略记录下来。
        - 需求不是架构：需求无关设计，也非用户界面：需求就是需要的东西。
    - 最后一根稻草
        - 许多项目失败，都可以归咎于不断扩大涉及范围————也称为功能膨胀、特性泛滥或需求蠕变。
        - 解决方法仍然是反馈。
    - 维护一张术语表
46. 处理无法解决的难题
    - 解谜的奥妙在于确定真正的（而不是想象的）约束条件，在这个约束条件下找到解开的方法。有些约束条件是绝对的，有些其实是一些先入为主的观念。
    - 自由度
        - 解决谜题的关键是，认识到你所受到的约束和你所拥有的自由度，因为认识到这些就会找到答案。
        - 不要跳出框框思考————找到框框
    - 跳出自身的局限
        - 简单的说，注意力分散的人在解决复杂问题是比有意识的人做的更好。
        - 将问题搁置一段时间或者找个人去解释一下这个问题。
    - 幸运眷顾有准备的人
        - 你的无意识大脑需要大量的原材料；过去的种种经验都会对答案有所贡献。
47. 携手共建
    - 与用户密切合作的建议贯穿本书；用户是你团队的一部分。在共同工作的第一个项目中，我们一起时间了现在被称为结对编程或群体编程的方法：一个人输入代码，而一个或多个团队成员一起评论、思考和解决问题。这是一种强大的合作方式，超越了没完没了的会议、备忘录和冗长的法律文件。
    - 这就是我们所说的"一起工作"的真正含义：不仅仅是提问、讨论、做笔记，还要在真正编码的同一时刻提问和讨论。
    - 不要一个人埋头钻进代码中
48. 敏捷的本质
    - 敏捷不是一个名词；敏捷有关你如何做事。
    - 我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：
        - 个体和互动高于流程和工具。
        - 工作的软件高于详尽的文档。
        - 客户合作高于合同谈判
        - 响应变化高于遵循计划
    - 永远不可能有一个叫敏捷的工艺流程
        - 敏捷指的是对变化的响应，对开始后所遇到的未知事情做出的响应。
    - 那么我们应该做什么
        1. 弄清楚你在哪里。
        2. 超想去的方向迈出有意义的最小一步。
        3. 评估在哪里终结，把弄坏的东西修好。
    - 还可以用来驱动设计
        - 为了使整个工作敏捷起来，需要实践优秀的设计，因为优秀的设计使事情容易改变。如果它容易改变，就可以在每个层面做调整，不会有任何犹豫。
49. 务实的团队
    - 维持小而稳定的团队
    - 禁止破窗：质量是一个团队问题。
    - 煮熟的青蛙：鼓励每个人积极监控环境嗯变化；对项目范围扩大、时间缩短、额外特性、新的环境————任何在最初的理解中没有的东西，都要留心。对新的需求要保持度量。团队不必对变化导致的失控心存抗拒————只需要知道变化正在发生就可以。
    - 为知识组合安排日程
        - 旧系统的维护
        - 流程的反思与精炼
        - 实验新技术
        - 学习和提升技能
    - 团队整体的对外交流
    - 不要重复自己
        - 良好的沟通是避免重复的关键。这里所说的"良好"，指的是即时、无摩擦力。
    - 团队的曳光弹
    - 自动化
         - 自动化是每个项目团队的基本组成部分。确保团队拥有构建工具的技能，以便可以构建和部署工具，用其来将项目开发和生产部署自动化。
50. 椰子派不上用场
    - 不要只盲目的模仿神器的模样，用椰子做的飞机派不上用场
    - 做能起作用的事，别赶时髦。
        - 怎样才能知道什么能起作用？ 试一试。
    - 同一尺码无法适应所有人
    - 真正的目的
        - 我们的目标是交付可以工作的软件，让用户马上能获得新的功能。
51. 务实的入门套件
    - 使用版本控制来驱动构建、测试和发布
    - 尽早测试，经常测试，自动测试
    - 知道所有的测试都已运行，编码才算完成
        - 单元测试
        - 集成测试
        - 确认和验证
        - 性能测试
        - 对测试做检测
    - 使用破坏者检测你的测试
    - 测试状态覆盖率，而非代码覆盖率
    - 每个bug只找一次：一个Bug一旦被人类测试员发现，这就应该是它被人类测试员发现的最后一次。要立即修改自动化测试，一边这个特定的bug，从此以后每次都被检查到。
    - 不要使用手动程序
52. 取悦用户
    - 用户真正要的不是代码，他们只是遇到某个业务问题，需要在目标和预算范围内解决。他们的信念是，通过与你的团队合作，能够做到这一点。
    - 挖掘用户期望，问一个简单的问题：这个项目在完成一个月（或其他时长）之后，你根据什么来判断自己已经取的成功？
    - 如果实现这些期望：
        - 确保团队中的每个人都清楚这些期望。
        - 在做决定的时候，想想哪条路更接近这些期望。
        - 根据期望严格分析用户需求。
        - 随着项目的进展，继续考虑这些期望。
    - 取悦用户，而不要只是交付代码
        如果你想取悦客户，就和他们建立其某种关系，这样即可积极的帮助他们解决问题。我们应该是"解决问题的人"。
53. 傲慢与偏见
    - 务实的程序员不会逃避责任。相反，我们乐于接受挑战，并让自己的专长广为人知。
    - 在作品上签名
        - 肯特贝克的基线编程建议共享代码的所有权。
        - "这是我写的，我与我的作品同在"。